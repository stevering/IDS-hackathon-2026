import { NextRequest, NextResponse } from "next/server";
import { cookies } from "next/headers";
import { auth } from "@ai-sdk/mcp";
import crypto from "crypto";
import {
  createSouthleftMcpOAuthProvider,
  SOUTHLEFT_COOKIE_STATE,
  SOUTHLEFT_MCP_URL,
} from "@/lib/southleft-mcp-oauth";
import { RedirectError, getBaseUrl } from "@/lib/figma-mcp-oauth";
import { writeOAuthResult } from "@/lib/oauth-store";

const COOKIE_OAUTH_SESSION = "southleft_oauth_session";

export async function GET(request: NextRequest) {
  const cookieStore = await cookies();
  const baseUrl = await getBaseUrl();

  // Enforce canonical domain
  const canonicalUrl = new URL(baseUrl);
  const currentHost = request.headers.get("host");
  if (currentHost && currentHost !== canonicalUrl.host) {
    const targetUrl = new URL(request.nextUrl.pathname + request.nextUrl.search, baseUrl);
    if (request.url !== targetUrl.toString()) {
      return NextResponse.redirect(targetUrl);
    }
  }

  // Per-session key generated by the client, used to match write→poll
  const session = request.nextUrl.searchParams.get("session") || "shared-dev-session";

  const state = crypto.randomBytes(16).toString("hex");

  const pendingCookies: Array<{ name: string; value: string; options: Record<string, unknown> }> = [];

  const provider = await createSouthleftMcpOAuthProvider(
    cookieStore,
    (name, value, options) => {
      pendingCookies.push({ name, value, options });
    },
    state,
  );

  const isSecure = baseUrl.startsWith("https");
  const sessionCookieOptions = {
    httpOnly: true,
    secure: isSecure,
    sameSite: "lax" as const,
    path: "/",
    maxAge: 600,
  };

  try {
    await auth(provider, {
      serverUrl: new URL(SOUTHLEFT_MCP_URL),
      scope: "file_content:read,library_content:read,file_variables:read",
    });

    // Tokens already valid — relay to polling via oauth-store
    const existingTokens = await provider.tokens();
    writeOAuthResult(session, {
      type: "southleft-mcp-auth",
      success: true,
      access_token: existingTokens?.access_token,
    });

    const response = NextResponse.redirect(new URL("/southleft-auth-success.html", baseUrl));
    response.cookies.delete(COOKIE_OAUTH_SESSION);
    return response;
  } catch (error) {
    if (error instanceof RedirectError) {
      const url = new URL(error.url);
      const redirectState = url.searchParams.get("state") || "";
      const response = new NextResponse(null, {
        status: 307,
        headers: { Location: error.url },
      });

      for (const c of pendingCookies) {
        response.cookies.set(c.name, c.value, c.options as Parameters<typeof response.cookies.set>[2]);
      }

      response.cookies.set(SOUTHLEFT_COOKIE_STATE, redirectState, sessionCookieOptions);
      // Persist session key through the OAuth redirect
      response.cookies.set(COOKIE_OAUTH_SESSION, session, sessionCookieOptions);

      return response;
    }

    console.error("[Southleft MCP OAuth] Auth error:", error);
    return NextResponse.json({ error: "OAuth initialization failed" }, { status: 500 });
  }
}
